#pragma once

#include "AManager.h"
#include "../States/AGameState.h"

using namespace std;

namespace ToD
{
	namespace Managers
	{
		////////////////////////////////////////////////////////////
		/// \brief Contains all currently used game states and manages them.
		///
		////////////////////////////////////////////////////////////
		class GameStateManager :
			public AManager<GameStateManager>
		{
			/// Typedefs
		private:
			////////////////////////////////////////////////////////////
			/// \brief Definition of the state stack type.
			///
			////////////////////////////////////////////////////////////
			typedef stack<AGameState*>										StateStack;

			/// Constructors, destructors
		public:
			////////////////////////////////////////////////////////////
			/// \brief The constructor (default constructor).
			///
			////////////////////////////////////////////////////////////
			GameStateManager();

			////////////////////////////////////////////////////////////
			/// \brief The destructor.
			///
			////////////////////////////////////////////////////////////
			~GameStateManager() IsDefault__;

			/// Properties
		public:
			////////////////////////////////////////////////////////////
			/// \brief Gets the static runtime type.
			///
			/// \return The static runtime type.
			///
			////////////////////////////////////////////////////////////
			virtual RuntimeType GetRuntimeType() const override;

			////////////////////////////////////////////////////////////
			/// \brief Gets the static runtime type.
			///
			/// \return The static runtime type.
			///
			////////////////////////////////////////////////////////////
			static RuntimeType RuntimeType();

		private:
			////////////////////////////////////////////////////////////
			/// \brief Gets the currently active game state.
			///
			/// \return Returns the currently active game state.
			///
			////////////////////////////////////////////////////////////
			AGameState* GetCurrentState();

			/// Methods
		public:
			////////////////////////////////////////////////////////////
			/// \brief Sets the initial state to use by the manager.
			///
			/// The state is moved into the game state manager.
			///
			/// \param l_state The state to set.
			///
			/// \exception std::exception when the initial state has already been set.
			///
			////////////////////////////////////////////////////////////
			void SetInitialState(AGameState* l_state);

			////////////////////////////////////////////////////////////
			/// \brief Updates the currently active game state.
			///
			/// \param l_gameTime Provides a snapshot of timing values.
			///
			////////////////////////////////////////////////////////////
			virtual void Update(const Time l_gameTime) override;

			////////////////////////////////////////////////////////////
			/// \brief Determines whether the game state manager has any states.
			///
			/// \return True if no state is currently managed; otherwise false.
			///
			////////////////////////////////////////////////////////////
			bool IsEmpty() const;

		private:
			////////////////////////////////////////////////////////////
			/// \brief Sets the next game state.
			///
			/// \param l_state The state to set.
			///
			////////////////////////////////////////////////////////////
			void SetNextState(AGameState* l_state);

			////////////////////////////////////////////////////////////
			/// \brief Closes the current state.
			///
			////////////////////////////////////////////////////////////
			void CloseCurrentState();

			/// Members
		private:
			StateStack														m_states; ///< Contains all currently used states.
		};
	}
}